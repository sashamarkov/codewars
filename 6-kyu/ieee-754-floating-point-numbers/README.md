<h2><a href=https://www.codewars.com/kata/5efcaedf95d7110017896ced/train/python target="_blank">IEEE 754 floating point numbers</a></h2><h3>6 kyu</h3><p><a href="https://en.wikipedia.org/wiki/IEEE_754" data-turbolinks="false" target="_blank">IEEE 754</a> is a standard for representing floating-point numbers (i.e. numbers that can have a fractional part and emulate real numbers).</p><p>Its use is currently ubiquitous in both software (programming languages implementations) and hardware (Floating Point Units (<a href="https://en.wikipedia.org/wiki/Floating-point_unit" data-turbolinks="false" target="_blank">FPU</a>) chips embedded in processors).</p><p>The 2 most widely used IEEE 754 formats are called the single precision (SP, encoded on 32 bits) and double precision (DP, encoded on 64 bits) formats.</p><ul><li>In <code>C/C++</code>,  these correspond respectively to the types <code>float</code> and <code>double</code>, in virtually every implementation that supports floating-point numbers</li><li>The default <code>Python</code> implementation, <code>CPython</code>, is written in <code>C</code> and represents Python <code>float</code>s  internally as <code>C</code> <code>double</code>s, and thus  as IEEE 754 DP</li><li>In <code>JavaScript</code>, all <code>Number</code>s are IEEE 754 DP values.</li><li>In <code>Rust</code>, these correspond respectively to the types <code>f32</code> and <code>f64</code>.</li><li>In <code>Java</code>, these correspond respectively to the types <code>float</code> and <code>double</code>.</li><li>Before <code>Lua 5.3</code>, all <code>number</code>s were IEEE 754 DP. Since <code>Lua 5.3</code>, <code>number</code>s can be either IEEE 754 DP or 2's complement integers.</li><li>The <code>Haskell</code> 2010 Language Report <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4" data-turbolinks="false" target="_blank">defines</a> the <code>Float</code> and <code>Double</code> types for single/double precision floating point numbers. Most, if not all, implementations of Haskell (including GHC) represent <code>Float/Double</code> internally in IEEE 754 SP/DP format.</li></ul><hr><p>As you can see on the images below, IEEE 754 numbers are divided into 3 fields : </p><ul><li>a sign bit;</li><li>an exponent encoded on 8 (SP) or 11 (DP) bits;</li><li>a mantissa (also called significand) encoded on 23 (SP) or 52 (DP) bits.</li></ul><img title="The IEEE 754 single-precision encoding scheme" alt="The IEEE 754 single-precision encoding scheme" style="background-color:white" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/1920px-Float_example.svg.png"><img title="The IEEE 754 double-precision encoding scheme" alt="The IEEE 754 double-precision encoding scheme" style="background-color:white" src="https://upload.wikimedia.org/wikipedia/commons/a/a9/IEEE_754_Double_Floating_Point_Format.svg"><hr><p>Your task is to write a function that takes as input a floating point number, and returns the binary IEEE 754 encoding of this number as a string, with fields separated by spaces for readability.If your programming language supports both SP and DP, you will have 2 functions to write, one for each type.</p><hr><h2 id="example">Example</h2><ul><li>Single Precision<pre><code>input:15.875output:"0 10000010 11111100000000000000000"</code></pre></li><li>Double Precision<pre><code>input:15.875output:"0 10000000010 1111110000000000000000000000000000000000000000000000"</code></pre></li></ul><hr><h2 id="note">Note</h2><p>If you find yourself writing overly complex code, you are probably on the wrong path. Your solution should only be concerned with the bit-pattern of the number, without dealing with its value.</p><hr><h2 id="related-katas">Related Katas</h2><p>If you want to solve the same problem with a different approach, try :</p><ul><li><a href="https://www.codewars.com/kata/540ddb07716ab397e1000797" data-turbolinks="false" target="_blank">Float to Binary Conversion</a> (in Javascript)</li></ul><p>This kata was inspired by this very interesting C kata :</p><ul><li><a href="https://www.codewars.com/kata/59e5f1b77905df91aa000024" data-turbolinks="false" target="_blank">C Puzzle: Extract Field from a Double Value</a></li></ul><p>My kata about classifying floating-point numbers:</p><ul><li><a href="https://www.codewars.com/kata/5f1ab7bd5af35f000f4ff875" data-turbolinks="false" target="_blank">Classify a floating point number</a></li></ul>