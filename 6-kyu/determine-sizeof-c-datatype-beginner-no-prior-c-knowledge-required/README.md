<h2><a href=https://www.codewars.com/kata/577ce2c97a3dbd74b7000059/train/javascript target="_blank">Determine sizeof C datatype - Beginner (No prior C knowledge required)</a></h2><h3>6 kyu</h3><h1 id="determine-sizeof-c-datatype---beginner-no-prior-c-knowledge-required">Determine sizeof C datatype - Beginner (No prior C knowledge required)</h1><p><em>NOTE: Although this Kata mentions certain basic C datatypes, you should be able to complete this Kata without any prior C programming knowledge.</em></p><h2 id="background">Background</h2><p>C is a simple and minimal yet powerful programming language first formulated in Bell Labs back in 1972, making it 46 years old as of 2018.  It wasn't the first high-level programming language (FORTRAN and Lisp, among a few other languages came before it) but it is generally considered the first widely portable programming language between different platforms / operating systems.  This made it highly successful and popular - it was consistently ranked as the top #1 - #2 programming language over the last 10 years (with Java being the other one) and its sheer influence on an entire <em>family</em> of modern programming languages (C++, Java, JS, C#, PHP, etc.) is simply undeniable.</p><p>C swiftly replaced assembly code (which was highly platform-dependent) in the role of operating systems and one major feature that led to its success was its simple yet highly flexible type system.  Its type system consists of the following (for the purposes of this Kata):</p><ul><li><p>Primitive integer types (signed): <code>char</code> (1 byte in memory), <code>short</code>/<code>int</code> (2 bytes in memory), <code>long</code> (4 bytes in memory), <code>long long</code> (8 bytes in memory).  Each also has a corresponding unsigned integer type which is denoted by prepending the keyword <code>unsigned</code> before the type and occupies the same number of bytes (e.g. <code>unsigned int</code> occupies 2 bytes in memory)</p></li><li><p>Floating point values: these denote the real numbers up to a certain precision. <code>float</code> occupies 4 bytes in memory while <code>double</code> occupies 8 bytes in memory.  Unlike the primitive integer values, floating-point values cannot be declared <code>unsigned</code>.  <em>N.B. there also exists a</em> <code>long double</code> <em>which occupies either 10 or 16 bytes in memory depending on implementation but it will not be covered in this Kata.</em></p></li><li><p>Structures (akin to a watered down version of classes in most modern OO languages): these are denoted with the keyword <code>struct</code>, optionally followed by a name and a pair of curly braces <code>{}</code> (mandatory).  Inside the pair of curly braces, the <strong>members</strong> of the given structure are defined (think of them as properties/fields in most modern OO languages).  For example, a <code>person</code> structure might be defined as such:</p><pre><code class="language-c"><span class="cm-keyword">struct</span> <span class="cm-def">person</span> {  <span class="cm-type">int</span> <span class="cm-variable">age</span>;  <span class="cm-type">char</span> <span class="cm-variable">gender</span>;  <span class="cm-comment">// Name of a person not defined in this structure because this involves C-strings which involves pointers, not covered in this Kata to maintain simplicity</span>};</code></pre><p>The size (in bytes) of a structure is the sum of the sizes of each of its members.  In the example above, since the <code>person</code> structure contains a single <code>int</code> member (2 bytes) and a single <code>char</code> member (1 byte), the <code>sizeof(struct person)</code> is 3 bytes.</p><p><em>N.B. If you find an online C compiler and find the size of the person structure as defined above in bytes, you will likely get an answer of 8 bytes.  This is due to</em> <code>int</code> <em>occupying 4 bytes instead of 2 in that implementation and that implementation keeping the size of the structure a multiple of 4 (so it would appear) but we will not worry about such (probably implementation-defined) behavior in this Kata; for all intents and purposes, the person structure occupies exactly 3 bytes in memory.</em></p></li><li><p>Unions: these (programmer-defined) composite datatypes allow the same memory space to be viewed in different ways.  Its declaration syntax is similar to that of declaring/defining structures, e.g.</p><pre><code class="language-c"><span class="cm-keyword">union</span> <span class="cm-def">long_long_n_double</span> {  <span class="cm-type">long</span> <span class="cm-type">long</span> <span class="cm-variable">n</span>;  <span class="cm-type">double</span> <span class="cm-variable">x</span>;};</code></pre><p>The major difference between <code>struct</code>s and <code>union</code>s is that in a union, all the members occupy the <strong>same</strong> memory space which leads to 2 interesting consequences:</p><ol><li>Changing the value of a member of a union also changes the value of <strong>all other members</strong> of the union</li><li>The size of a <code>union</code> is determined solely by the size of the member that occupies the most bytes in memory.  In the above example, since the 2 members of <code>long_long_n_double</code>, namely <code>n</code> and <code>x</code> have types <code>long long</code> (8 bytes) and <code>double</code> (8 bytes) respectively, the <code>sizeof(union long_long_n_double)</code> is max(8, 8) = 8 bytes in memory.</li></ol></li></ul><p>There are in fact a few other composite types in C such as arrays, pointers and function pointers (and bit fields as well!) but they will not be covered in this Kata for the sake of simplicity.</p><p>Before we move on to the task at hand, let's see if you actually understood what was being explained above.  Try to determine the size of the data structure below by hand (solution provided below code example):</p><pre><code class="language-c"><span class="cm-keyword">struct</span> {  <span class="cm-type">unsigned</span> <span class="cm-type">char</span> <span class="cm-variable">c1</span>, <span class="cm-variable">c2</span>, <span class="cm-variable">c3</span>; <span class="cm-comment">// &lt;- IMPORTANT! **Three** unsigned chars here, **not** one</span>  <span class="cm-type">double</span> <span class="cm-variable">d1</span>, <span class="cm-variable">d2</span>; <span class="cm-comment">// Two doubles</span>  <span class="cm-keyword">union</span> {    <span class="cm-type">unsigned</span> <span class="cm-type">short</span> <span class="cm-variable">s2</span>, <span class="cm-variable">s3</span>, <span class="cm-variable">s4</span>;    <span class="cm-type">long</span> <span class="cm-type">long</span> <span class="cm-variable">ll1</span>;    <span class="cm-type">float</span> <span class="cm-variable">f1</span>, <span class="cm-variable">f2</span>;    <span class="cm-keyword">struct</span> {      <span class="cm-type">long</span> <span class="cm-variable">l1</span>;      <span class="cm-type">unsigned</span> <span class="cm-type">int</span> <span class="cm-variable">i1</span>;    };  };  <span class="cm-type">short</span> <span class="cm-variable">s1</span>;}</code></pre><p><a data-turbolinks="false" target="_blank">Click here to reveal solution</a></p><div style="display:none" id="_solution">3 \* 1 + 2 \* 8 + max(3 \* 2, 8, 4 \* 2, 4 + 2) + 2 = 29 bytes in memory</div><h2 id="task">Task</h2><p>Write a <code>sizeof()</code> function which accepts a representation of a C datatype and returns its size in bytes as an integer.  Note that this parallels the <code>sizeof</code> builtin construct of the C language.</p><p>A representation of a C datatype in this Kata can take one of two possible forms:</p><ul><li><p>A string for primitive datatypes (integers and floating point values).  For example, <code>sizeof("char") == 1</code> and <code>sizeof("unsigned long") == 4</code>.  The types tested in this Kata will be: <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> and their unsigned counterparts; <code>float</code> and <code>double</code>.</p></li><li><p>An object for structures and unions.  Such objects will have two properties:</p><ul><li>A <code>type</code> property which is either <code>"struct"</code> or <code>"union"</code></li><li>A <code>members</code> property which is an array containing representations of the members of the given composite datatype.</li></ul><p>E.g. A <code>struct {int n1, n2; float f; union {};}</code> in C will have a representation of <code>{type: "struct", members: ["int", "int", "float", {type: "union", members: []}]}</code></p></li></ul><p>You may assume all input passed into your function is valid.</p>